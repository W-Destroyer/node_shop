{"version":3,"sources":["public/src/js_components/react-router/modules/match.js"],"names":["match","callback","history","routes","location","options","transitionManager","createLocation","getCurrentLocation","error","redirectLocation","nextState","renderProps","router","matchContext"],"mappings":";;;;;;AAAA;;AACA;;;;AAEA;;;;AACA;;;;AACA;;AACA;;;;;;AAEA;;;;;;;;;AASA,SAASA,KAAT,OAA0DC,QAA1D,EAAoE;AAAA,MAAnDC,OAAmD,QAAnDA,OAAmD;AAAA,MAA1CC,MAA0C,QAA1CA,MAA0C;AAAA,MAAlCC,QAAkC,QAAlCA,QAAkC;AAAA,MAArBC,OAAqB;;AAClE,IACEH,WAAWE,QADb,4EAEE,qCAFF;;AAKAF,YAAUA,UAAUA,OAAV,GAAoB,mCAAoBG,OAApB,CAA9B;AACA,MAAMC,oBAAoB,uCACxBJ,OADwB,EAExB,8BAAaC,MAAb,CAFwB,CAA1B;;AAKA,MAAIC,QAAJ,EAAc;AACZ;AACAA,eAAWF,QAAQK,cAAR,CAAuBH,QAAvB,CAAX;AACD,GAHD,MAGO;AACLA,eAAWF,QAAQM,kBAAR,EAAX;AACD;;AAEDF,oBAAkBN,KAAlB,CAAwBI,QAAxB,EAAkC,UAACK,KAAD,EAAQC,gBAAR,EAA0BC,SAA1B,EAAwC;AACxE,QAAIC,oBAAJ;;AAEA,QAAID,SAAJ,EAAe;AACb,UAAME,SAAS,qCAAmBX,OAAnB,EAA4BI,iBAA5B,EAA+CK,SAA/C,CAAf;AACAC,iCACKD,SADL;AAEEE,sBAFF;AAGEC,sBAAc,EAAER,oCAAF,EAAqBO,cAArB;AAHhB;AAKD;;AAEDZ,aACEQ,KADF,EAEEC,oBAAoBR,QAAQK,cAAR,CAAuBG,gBAAvB,mBAFtB,EAGEE,WAHF;AAKD,GAjBD;AAkBD;;kBAEcZ,K","file":"match.js","sourceRoot":"/Users/creator/workspace/furuida","sourcesContent":["import { REPLACE } from 'history/lib/Actions'\nimport invariant from 'invariant'\n\nimport createMemoryHistory from './createMemoryHistory'\nimport createTransitionManager from './createTransitionManager'\nimport { createRoutes } from './RouteUtils'\nimport { createRouterObject } from './RouterUtils'\n\n/**\n * A high-level API to be used for server-side rendering.\n *\n * This function matches a location to a set of routes and calls\n * callback(error, redirectLocation, renderProps) when finished.\n *\n * Note: You probably don't want to use this in a browser unless you're using\n * server-side rendering with async routes.\n */\nfunction match({ history, routes, location, ...options }, callback) {\n  invariant(\n    history || location,\n    'match needs a history or a location'\n  )\n\n  history = history ? history : createMemoryHistory(options)\n  const transitionManager = createTransitionManager(\n    history,\n    createRoutes(routes)\n  )\n\n  if (location) {\n    // Allow match({ location: '/the/path', ... })\n    location = history.createLocation(location)\n  } else {\n    location = history.getCurrentLocation()\n  }\n\n  transitionManager.match(location, (error, redirectLocation, nextState) => {\n    let renderProps\n\n    if (nextState) {\n      const router = createRouterObject(history, transitionManager, nextState)\n      renderProps = {\n        ...nextState,\n        router,\n        matchContext: { transitionManager, router }\n      }\n    }\n\n    callback(\n      error,\n      redirectLocation && history.createLocation(redirectLocation, REPLACE),\n      renderProps\n    )\n  })\n}\n\nexport default match\n"]}