{"version":3,"sources":["public/src/js_components/react-router/modules/isActive.js"],"names":["isActive","deepEqual","a","b","Array","isArray","length","every","item","index","p","Object","prototype","hasOwnProperty","call","undefined","String","pathIsActive","pathname","currentPathname","charAt","routeIsActive","routes","params","remainingPathname","paramNames","paramValues","i","len","route","pattern","path","matched","paramName","queryIsActive","query","activeQuery","indexOnly","currentLocation"],"mappings":"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","file":"isActive.js","sourceRoot":"/Users/creator/workspace/furuida","sourcesContent":["import { matchPattern } from './PatternUtils'\n\nfunction deepEqual(a, b) {\n  if (a == b)\n    return true\n\n  if (a == null || b == null)\n    return false\n\n  if (Array.isArray(a)) {\n    return (\n      Array.isArray(b) &&\n      a.length === b.length &&\n      a.every((item, index) => deepEqual(item, b[index]))\n    )\n  }\n\n  if (typeof a === 'object') {\n    for (let p in a) {\n      if (!Object.prototype.hasOwnProperty.call(a, p)) {\n        continue\n      }\n\n      if (a[p] === undefined) {\n        if (b[p] !== undefined) {\n          return false\n        }\n      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {\n        return false\n      } else if (!deepEqual(a[p], b[p])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  return String(a) === String(b)\n}\n\n/**\n * Returns true if the current pathname matches the supplied one, net of\n * leading and trailing slash normalization. This is sufficient for an\n * indexOnly route match.\n */\nfunction pathIsActive(pathname, currentPathname) {\n  // Normalize leading slash for consistency. Leading slash on pathname has\n  // already been normalized in isActive. See caveat there.\n  if (currentPathname.charAt(0) !== '/') {\n    currentPathname = `/${currentPathname}`\n  }\n\n  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show\n  // `/foo` as active, but in this case, we would already have failed the\n  // match.\n  if (pathname.charAt(pathname.length - 1) !== '/') {\n    pathname += '/'\n  }\n  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {\n    currentPathname += '/'\n  }\n\n  return currentPathname === pathname\n}\n\n/**\n * Returns true if the given pathname matches the active routes and params.\n */\nfunction routeIsActive(pathname, routes, params) {\n  let remainingPathname = pathname, paramNames = [], paramValues = []\n\n  // for...of would work here but it's probably slower post-transpilation.\n  for (let i = 0, len = routes.length; i < len; ++i) {\n    const route = routes[i]\n    const pattern = route.path || ''\n\n    if (pattern.charAt(0) === '/') {\n      remainingPathname = pathname\n      paramNames = []\n      paramValues = []\n    }\n\n    if (remainingPathname !== null && pattern) {\n      const matched = matchPattern(pattern, remainingPathname)\n      if (matched) {\n        remainingPathname = matched.remainingPathname\n        paramNames = [ ...paramNames, ...matched.paramNames ]\n        paramValues = [ ...paramValues, ...matched.paramValues ]\n      } else {\n        remainingPathname = null\n      }\n\n      if (remainingPathname === '') {\n        // We have an exact match on the route. Just check that all the params\n        // match.\n        // FIXME: This doesn't work on repeated params.\n        return paramNames.every((paramName, index) => (\n          String(paramValues[index]) === String(params[paramName])\n        ))\n      }\n    }\n  }\n\n  return false\n}\n\n/**\n * Returns true if all key/value pairs in the given query are\n * currently active.\n */\nfunction queryIsActive(query, activeQuery) {\n  if (activeQuery == null)\n    return query == null\n\n  if (query == null)\n    return true\n\n  return deepEqual(query, activeQuery)\n}\n\n/**\n * Returns true if a <Link> to the given pathname/query combination is\n * currently active.\n */\nexport default function isActive(\n  { pathname, query }, indexOnly, currentLocation, routes, params\n) {\n  if (currentLocation == null)\n    return false\n\n  // TODO: This is a bit ugly. It keeps around support for treating pathnames\n  // without preceding slashes as absolute paths, but possibly also works\n  // around the same quirks with basenames as in matchRoutes.\n  if (pathname.charAt(0) !== '/') {\n    pathname = `/${pathname}`\n  }\n\n  if (!pathIsActive(pathname, currentLocation.pathname)) {\n    // The path check is necessary and sufficient for indexOnly, but otherwise\n    // we still need to check the routes.\n    if (indexOnly || !routeIsActive(pathname, routes, params)) {\n      return false\n    }\n  }\n\n  return queryIsActive(query, currentLocation.query)\n}\n"]}