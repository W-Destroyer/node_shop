{"version":3,"sources":["public/src/js_components/react-router/modules/createTransitionManager.js"],"names":["createTransitionManager","hasAnyProperties","object","p","Object","prototype","hasOwnProperty","call","history","routes","state","isActive","location","indexOnly","createLocation","params","partialNextState","match","callback","finishMatch","error","nextState","leaveRoutes","changeRoutes","enterRoutes","filter","indexOf","route","forEach","removeListenBeforeHooksForRoute","redirectInfo","handleErrorOrRedirect","finishEnterHooks","components","RouteGuid","getRouteID","create","__id__","RouteHooks","getRouteHooksForRoutes","map","hook","transitionHook","hooks","result","i","len","length","beforeUnloadHook","message","unlistenBefore","unlistenBeforeUnload","routeID","listenBeforeLeavingRoute","thereWereNoRouteHooks","listenBefore","listenBeforeUnload","listen","listener","historyListener","redirectLocation","replace","pathname","search","hash","unsubscribe","getCurrentLocation"],"mappings":"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","file":"createTransitionManager.js","sourceRoot":"/Users/creator/workspace/furuida","sourcesContent":["import warning from './routerWarning'\nimport computeChangedRoutes from './computeChangedRoutes'\nimport { runEnterHooks, runChangeHooks, runLeaveHooks } from './TransitionUtils'\nimport _isActive from './isActive'\nimport getComponents from './getComponents'\nimport matchRoutes from './matchRoutes'\n\nfunction hasAnyProperties(object) {\n  for (const p in object)\n    if (Object.prototype.hasOwnProperty.call(object, p))\n      return true\n\n  return false\n}\n\nexport default function createTransitionManager(history, routes) {\n  let state = {}\n\n  // Signature should be (location, indexOnly), but needs to support (path,\n  // query, indexOnly)\n  function isActive(location, indexOnly) {\n    location = history.createLocation(location)\n\n    return _isActive(\n      location, indexOnly, state.location, state.routes, state.params\n    )\n  }\n\n  let partialNextState\n\n  function match(location, callback) {\n    if (partialNextState && partialNextState.location === location) {\n      // Continue from where we left off.\n      finishMatch(partialNextState, callback)\n    } else {\n      matchRoutes(routes, location, function (error, nextState) {\n        if (error) {\n          callback(error)\n        } else if (nextState) {\n          finishMatch({ ...nextState, location }, callback)\n        } else {\n          callback()\n        }\n      })\n    }\n  }\n\n  function finishMatch(nextState, callback) {\n    const { leaveRoutes, changeRoutes, enterRoutes } = computeChangedRoutes(state, nextState)\n\n    runLeaveHooks(leaveRoutes, state)\n\n    // Tear down confirmation hooks for left routes\n    leaveRoutes\n      .filter(route => enterRoutes.indexOf(route) === -1)\n      .forEach(removeListenBeforeHooksForRoute)\n\n    // change and enter hooks are run in series\n    runChangeHooks(changeRoutes, state, nextState, (error, redirectInfo) => {\n      if (error || redirectInfo)\n        return handleErrorOrRedirect(error, redirectInfo)\n\n      runEnterHooks(enterRoutes, nextState, finishEnterHooks)\n    })\n\n    function finishEnterHooks(error, redirectInfo) {\n      if (error || redirectInfo)\n        return handleErrorOrRedirect(error, redirectInfo)\n\n      // TODO: Fetch components after state is updated.\n      getComponents(nextState, function (error, components) {\n        if (error) {\n          callback(error)\n        } else {\n          // TODO: Make match a pure function and have some other API\n          // for \"match and update state\".\n          callback(null, null, (\n            state = { ...nextState, components })\n          )\n        }\n      })\n    }\n\n    function handleErrorOrRedirect(error, redirectInfo) {\n      if (error) callback(error)\n      else callback(null, redirectInfo)\n    }\n  }\n\n  let RouteGuid = 1\n\n  function getRouteID(route, create = false) {\n    return route.__id__ || create && (route.__id__ = RouteGuid++)\n  }\n\n  const RouteHooks = Object.create(null)\n\n  function getRouteHooksForRoutes(routes) {\n    return routes\n      .map(route => RouteHooks[getRouteID(route)])\n      .filter(hook => hook)\n  }\n\n  function transitionHook(location, callback) {\n    matchRoutes(routes, location, function (error, nextState) {\n      if (nextState == null) {\n        // TODO: We didn't actually match anything, but hang\n        // onto error/nextState so we don't have to matchRoutes\n        // again in the listen callback.\n        callback()\n        return\n      }\n\n      // Cache some state here so we don't have to\n      // matchRoutes() again in the listen callback.\n      partialNextState = { ...nextState, location }\n\n      const hooks = getRouteHooksForRoutes(\n        computeChangedRoutes(state, partialNextState).leaveRoutes\n      )\n\n      let result\n      for (let i = 0, len = hooks.length; result == null && i < len; ++i) {\n        // Passing the location arg here indicates to\n        // the user that this is a transition hook.\n        result = hooks[i](location)\n      }\n\n      callback(result)\n    })\n  }\n\n  /* istanbul ignore next: untestable with Karma */\n  function beforeUnloadHook() {\n    // Synchronously check to see if any route hooks want\n    // to prevent the current window/tab from closing.\n    if (state.routes) {\n      const hooks = getRouteHooksForRoutes(state.routes)\n\n      let message\n      for (let i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {\n        // Passing no args indicates to the user that this is a\n        // beforeunload hook. We don't know the next location.\n        message = hooks[i]()\n      }\n\n      return message\n    }\n  }\n\n  let unlistenBefore, unlistenBeforeUnload\n\n  function removeListenBeforeHooksForRoute(route) {\n    const routeID = getRouteID(route)\n    if (!routeID) {\n      return\n    }\n\n    delete RouteHooks[routeID]\n\n    if (!hasAnyProperties(RouteHooks)) {\n      // teardown transition & beforeunload hooks\n      if (unlistenBefore) {\n        unlistenBefore()\n        unlistenBefore = null\n      }\n\n      if (unlistenBeforeUnload) {\n        unlistenBeforeUnload()\n        unlistenBeforeUnload = null\n      }\n    }\n  }\n\n  /**\n   * Registers the given hook function to run before leaving the given route.\n   *\n   * During a normal transition, the hook function receives the next location\n   * as its only argument and can return either a prompt message (string) to show the user,\n   * to make sure they want to leave the page; or `false`, to prevent the transition.\n   * Any other return value will have no effect.\n   *\n   * During the beforeunload event (in browsers) the hook receives no arguments.\n   * In this case it must return a prompt message to prevent the transition.\n   *\n   * Returns a function that may be used to unbind the listener.\n   */\n  function listenBeforeLeavingRoute(route, hook) {\n    const thereWereNoRouteHooks = !hasAnyProperties(RouteHooks)\n    const routeID = getRouteID(route, true)\n\n    RouteHooks[routeID] = hook\n\n    if (thereWereNoRouteHooks) {\n      // setup transition & beforeunload hooks\n      unlistenBefore = history.listenBefore(transitionHook)\n\n      if (history.listenBeforeUnload)\n        unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook)\n    }\n\n    return function () {\n      removeListenBeforeHooksForRoute(route)\n    }\n  }\n\n  /**\n   * This is the API for stateful environments. As the location\n   * changes, we update state and call the listener. We can also\n   * gracefully handle errors and redirects.\n   */\n  function listen(listener) {\n    function historyListener(location) {\n      if (state.location === location) {\n        listener(null, state)\n      } else {\n        match(location, function (error, redirectLocation, nextState) {\n          if (error) {\n            listener(error)\n          } else if (redirectLocation) {\n            history.replace(redirectLocation)\n          } else if (nextState) {\n            listener(null, nextState)\n          } else {\n            warning(\n              false,\n              'Location \"%s\" did not match any routes',\n              location.pathname + location.search + location.hash\n            )\n          }\n        })\n      }\n    }\n\n    // TODO: Only use a single history listener. Otherwise we'll end up with\n    // multiple concurrent calls to match.\n\n    // Set up the history listener first in case the initial match redirects.\n    const unsubscribe = history.listen(historyListener)\n\n    if (state.location) {\n      // Picking up on a matchContext.\n      listener(null, state)\n    } else {\n      historyListener(history.getCurrentLocation())\n    }\n\n    return unsubscribe\n  }\n\n  return {\n    isActive,\n    match,\n    listenBeforeLeavingRoute,\n    listen\n  }\n}\n"]}