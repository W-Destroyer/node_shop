{"version":3,"sources":["public/src/js_components/react-router/modules/TransitionUtils.js"],"names":["runEnterHooks","runChangeHooks","runLeaveHooks","PendingHooks","hooks","add","push","hook","remove","filter","h","has","indexOf","clear","enterHooks","changeHooks","createTransitionHook","route","asyncArity","pendingHooks","isSync","length","transitionHook","args","apply","callback","getEnterHooks","routes","reduce","onEnter","getChangeHooks","onChange","runTransitionHooks","iter","redirectInfo","replace","location","index","next","done","error","nextState","wrappedNext","state","prevState","i","len","onLeave","call"],"mappings":"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","file":"TransitionUtils.js","sourceRoot":"/Users/creator/workspace/furuida","sourcesContent":["import { loopAsync } from './AsyncUtils'\n\nclass PendingHooks {\n  hooks = []\n  add = hook => this.hooks.push(hook)\n  remove = hook => this.hooks = this.hooks.filter(h => h !== hook)\n  has = hook => this.hooks.indexOf(hook) !== -1\n  clear = () => this.hooks = []\n}\n\nconst enterHooks = new PendingHooks()\nconst changeHooks = new PendingHooks()\n\nfunction createTransitionHook(hook, route, asyncArity, pendingHooks) {\n  const isSync = hook.length < asyncArity\n\n  const transitionHook = (...args) => {\n    hook.apply(route, args)\n\n    if (isSync) {\n      let callback = args[args.length - 1]\n      // Assume hook executes synchronously and\n      // automatically call the callback.\n      callback()\n    }\n  }\n\n  pendingHooks.add(transitionHook)\n\n  return transitionHook\n}\n\nfunction getEnterHooks(routes) {\n  return routes.reduce(function (hooks, route) {\n    if (route.onEnter)\n      hooks.push(createTransitionHook(route.onEnter, route, 3, enterHooks))\n    return hooks\n  }, [])\n}\n\nfunction getChangeHooks(routes) {\n  return routes.reduce(function (hooks, route) {\n    if (route.onChange)\n      hooks.push(createTransitionHook(route.onChange, route, 4, changeHooks))\n    return hooks\n  }, [])\n}\n\nfunction runTransitionHooks(length, iter, callback) {\n  if (!length) {\n    callback()\n    return\n  }\n\n  let redirectInfo\n  function replace(location) {\n    redirectInfo = location\n  }\n\n  loopAsync(length, function (index, next, done) {\n    iter(index, replace, function (error) {\n      if (error || redirectInfo) {\n        done(error, redirectInfo) // No need to continue.\n      } else {\n        next()\n      }\n    })\n  }, callback)\n}\n\n/**\n * Runs all onEnter hooks in the given array of routes in order\n * with onEnter(nextState, replace, callback) and calls\n * callback(error, redirectInfo) when finished. The first hook\n * to use replace short-circuits the loop.\n *\n * If a hook needs to run asynchronously, it may use the callback\n * function. However, doing so will cause the transition to pause,\n * which could lead to a non-responsive UI if the hook is slow.\n */\nexport function runEnterHooks(routes, nextState, callback) {\n  enterHooks.clear()\n  const hooks = getEnterHooks(routes)\n  return runTransitionHooks(hooks.length, (index, replace, next) => {\n    const wrappedNext = (...args) => {\n      if (enterHooks.has(hooks[index])) {\n        next(...args)\n        enterHooks.remove(hooks[index])\n      }\n    }\n    hooks[index](nextState, replace, wrappedNext)\n  }, callback)\n}\n\n/**\n * Runs all onChange hooks in the given array of routes in order\n * with onChange(prevState, nextState, replace, callback) and calls\n * callback(error, redirectInfo) when finished. The first hook\n * to use replace short-circuits the loop.\n *\n * If a hook needs to run asynchronously, it may use the callback\n * function. However, doing so will cause the transition to pause,\n * which could lead to a non-responsive UI if the hook is slow.\n */\nexport function runChangeHooks(routes, state, nextState, callback) {\n  changeHooks.clear()\n  const hooks = getChangeHooks(routes)\n  return runTransitionHooks(hooks.length, (index, replace, next) => {\n    const wrappedNext = (...args) => {\n      if (changeHooks.has(hooks[index])) {\n        next(...args)\n        changeHooks.remove(hooks[index])\n      }\n    }\n    hooks[index](state, nextState, replace, wrappedNext)\n  }, callback)\n}\n\n/**\n * Runs all onLeave hooks in the given array of routes in order.\n */\nexport function runLeaveHooks(routes, prevState) {\n  for (let i = 0, len = routes.length; i < len; ++i)\n    if (routes[i].onLeave)\n      routes[i].onLeave.call(routes[i], prevState)\n}\n"]}