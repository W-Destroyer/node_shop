{"version":3,"sources":["public/src/js_components/react-router/modules/PatternUtils.js"],"names":["compilePattern","matchPattern","getParamNames","getParams","formatPattern","escapeRegExp","string","replace","_compilePattern","pattern","regexpSource","paramNames","tokens","match","lastIndex","matcher","exec","index","push","slice","length","CompiledPatternsCache","Object","create","pathname","charAt","RegExp","matchedPath","remainingPathname","substr","paramValues","map","v","decodeURIComponent","params","forEach","paramName","parenCount","splatIndex","parenHistory","token","paramValue","i","len","Array","isArray","splat","encodeURI","parenText","pop","substring","curTokenIdx","indexOf","tokensSubset","nextParenIdx","join","encodeURIComponent"],"mappings":"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","file":"PatternUtils.js","sourceRoot":"/Users/creator/workspace/furuida","sourcesContent":["import invariant from 'invariant'\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction _compilePattern(pattern) {\n  let regexpSource = ''\n  const paramNames = []\n  const tokens = []\n\n  let match, lastIndex = 0, matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\\*\\*|\\*|\\(|\\)|\\\\\\(|\\\\\\)/g\n  while ((match = matcher.exec(pattern))) {\n    if (match.index !== lastIndex) {\n      tokens.push(pattern.slice(lastIndex, match.index))\n      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index))\n    }\n\n    if (match[1]) {\n      regexpSource += '([^/]+)'\n      paramNames.push(match[1])\n    } else if (match[0] === '**') {\n      regexpSource += '(.*)'\n      paramNames.push('splat')\n    } else if (match[0] === '*') {\n      regexpSource += '(.*?)'\n      paramNames.push('splat')\n    } else if (match[0] === '(') {\n      regexpSource += '(?:'\n    } else if (match[0] === ')') {\n      regexpSource += ')?'\n    } else if (match[0] === '\\\\(') {\n      regexpSource += '\\\\('\n    } else if (match[0] === '\\\\)') {\n      regexpSource += '\\\\)'\n    }\n\n    tokens.push(match[0])\n\n    lastIndex = matcher.lastIndex\n  }\n\n  if (lastIndex !== pattern.length) {\n    tokens.push(pattern.slice(lastIndex, pattern.length))\n    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length))\n  }\n\n  return {\n    pattern,\n    regexpSource,\n    paramNames,\n    tokens\n  }\n}\n\nconst CompiledPatternsCache = Object.create(null)\n\nexport function compilePattern(pattern) {\n  if (!CompiledPatternsCache[pattern])\n    CompiledPatternsCache[pattern] = _compilePattern(pattern)\n\n  return CompiledPatternsCache[pattern]\n}\n\n/**\n * Attempts to match a pattern on the given pathname. Patterns may use\n * the following special characters:\n *\n * - :paramName     Matches a URL segment up to the next /, ?, or #. The\n *                  captured string is considered a \"param\"\n * - ()             Wraps a segment of the URL that is optional\n * - *              Consumes (non-greedy) all characters up to the next\n *                  character in the pattern, or to the end of the URL if\n *                  there is none\n * - **             Consumes (greedy) all characters up to the next character\n *                  in the pattern, or to the end of the URL if there is none\n *\n *  The function calls callback(error, matched) when finished.\n * The return value is an object with the following properties:\n *\n * - remainingPathname\n * - paramNames\n * - paramValues\n */\nexport function matchPattern(pattern, pathname) {\n  // Ensure pattern starts with leading slash for consistency with pathname.\n  if (pattern.charAt(0) !== '/') {\n    pattern = `/${pattern}`\n  }\n  let { regexpSource, paramNames, tokens } = compilePattern(pattern)\n\n  if (pattern.charAt(pattern.length - 1) !== '/') {\n    regexpSource += '/?' // Allow optional path separator at end.\n  }\n\n  // Special-case patterns like '*' for catch-all routes.\n  if (tokens[tokens.length - 1] === '*') {\n    regexpSource += '$'\n  }\n\n  const match = pathname.match(new RegExp(`^${regexpSource}`, 'i'))\n  if (match == null) {\n    return null\n  }\n\n  const matchedPath = match[0]\n  let remainingPathname = pathname.substr(matchedPath.length)\n\n  if (remainingPathname) {\n    // Require that the match ends at a path separator, if we didn't match\n    // the full path, so any remaining pathname is a new path segment.\n    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {\n      return null\n    }\n\n    // If there is a remaining pathname, treat the path separator as part of\n    // the remaining pathname for properly continuing the match.\n    remainingPathname = `/${remainingPathname}`\n  }\n\n  return {\n    remainingPathname,\n    paramNames,\n    paramValues: match.slice(1).map(v => v && decodeURIComponent(v))\n  }\n}\n\nexport function getParamNames(pattern) {\n  return compilePattern(pattern).paramNames\n}\n\nexport function getParams(pattern, pathname) {\n  const match = matchPattern(pattern, pathname)\n  if (!match) {\n    return null\n  }\n\n  const { paramNames, paramValues } = match\n  const params = {}\n\n  paramNames.forEach((paramName, index) => {\n    params[paramName] = paramValues[index]\n  })\n\n  return params\n}\n\n/**\n * Returns a version of the given pattern with params interpolated. Throws\n * if there is a dynamic segment of the pattern for which there is no param.\n */\nexport function formatPattern(pattern, params) {\n  params = params || {}\n\n  const { tokens } = compilePattern(pattern)\n  let parenCount = 0, pathname = '', splatIndex = 0, parenHistory = []\n\n  let token, paramName, paramValue\n  for (let i = 0, len = tokens.length; i < len; ++i) {\n    token = tokens[i]\n\n    if (token === '*' || token === '**') {\n      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat\n\n      invariant(\n        paramValue != null || parenCount > 0,\n        'Missing splat #%s for path \"%s\"',\n        splatIndex, pattern\n      )\n\n      if (paramValue != null)\n        pathname += encodeURI(paramValue)\n    } else if (token === '(') {\n      parenHistory[parenCount] = ''\n      parenCount += 1\n    } else if (token === ')') {\n      const parenText = parenHistory.pop()\n      parenCount -= 1\n\n      if (parenCount)\n        parenHistory[parenCount - 1] += parenText\n      else\n        pathname += parenText\n    } else if (token === '\\\\(') {\n      pathname += '('\n    } else if (token === '\\\\)') {\n      pathname += ')'\n    } else if (token.charAt(0) === ':') {\n      paramName = token.substring(1)\n      paramValue = params[paramName]\n\n      invariant(\n        paramValue != null || parenCount > 0,\n        'Missing \"%s\" parameter for path \"%s\"',\n        paramName, pattern\n      )\n\n      if (paramValue == null) {\n        if (parenCount) {\n          parenHistory[parenCount - 1] = ''\n\n          const curTokenIdx = tokens.indexOf(token)\n          const tokensSubset = tokens.slice(curTokenIdx, tokens.length)\n          let nextParenIdx = -1\n\n          for (let i = 0; i < tokensSubset.length; i++) {\n            if (tokensSubset[i] == ')') {\n              nextParenIdx = i\n              break\n            }\n          }\n\n          invariant(\n            nextParenIdx > 0,\n            'Path \"%s\" is missing end paren at segment \"%s\"', pattern, tokensSubset.join('')\n          )\n\n          // jump to ending paren\n          i = curTokenIdx + nextParenIdx - 1\n        }\n      }\n      else if (parenCount)\n        parenHistory[parenCount - 1] += encodeURIComponent(paramValue)\n      else\n        pathname += encodeURIComponent(paramValue)\n\n    } else {\n      if (parenCount)\n        parenHistory[parenCount - 1] += token\n      else\n        pathname += token\n    }\n  }\n\n  invariant(\n    parenCount <= 0,\n    'Path \"%s\" is missing end paren', pattern\n  )\n\n  return pathname.replace(/\\/+/g, '/')\n}\n"]}