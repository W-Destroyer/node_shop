{"version":3,"sources":["node_modules/react-router-redux/src/sync.js"],"names":["syncHistoryWithStore","defaultSelectLocationState","state","routing","history","store","selectLocationState","adjustUrlOnReplay","getState","Error","initialLocation","isTimeTraveling","unsubscribeFromStore","unsubscribeFromHistory","currentLocation","getLocationInStore","useInitialIfEmpty","locationState","locationBeforeTransitions","undefined","handleStoreChange","locationInStore","transitionTo","action","subscribe","handleLocationChange","location","dispatch","type","payload","listen","getCurrentLocation","listener","lastPublishedLocation","unsubscribed","unsubscribe"],"mappings":"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","file":"sync.js","sourceRoot":"/Users/creator/workspace/furuida","sourcesContent":["import { LOCATION_CHANGE } from './reducer'\n\nconst defaultSelectLocationState = state => state.routing\n\n/**\n * This function synchronizes your history state with the Redux store.\n * Location changes flow from history to the store. An enhanced history is\n * returned with a listen method that responds to store updates for location.\n *\n * When this history is provided to the router, this means the location data\n * will flow like this:\n * history.push -> store.dispatch -> enhancedHistory.listen -> router\n * This ensures that when the store state changes due to a replay or other\n * event, the router will be updated appropriately and can transition to the\n * correct router state.\n */\nexport default function syncHistoryWithStore(history, store, {\n  selectLocationState = defaultSelectLocationState,\n  adjustUrlOnReplay = true\n} = {}) {\n  // Ensure that the reducer is mounted on the store and functioning properly.\n  if (typeof selectLocationState(store.getState()) === 'undefined') {\n    throw new Error(\n      'Expected the routing state to be available either as `state.routing` ' +\n      'or as the custom expression you can specify as `selectLocationState` ' +\n      'in the `syncHistoryWithStore()` options. ' +\n      'Ensure you have added the `routerReducer` to your store\\'s ' +\n      'reducers via `combineReducers` or whatever method you use to isolate ' +\n      'your reducers.'\n    )\n  }\n\n  let initialLocation\n  let isTimeTraveling\n  let unsubscribeFromStore\n  let unsubscribeFromHistory\n  let currentLocation\n\n  // What does the store say about current location?\n  const getLocationInStore = (useInitialIfEmpty) => {\n    const locationState = selectLocationState(store.getState())\n    return locationState.locationBeforeTransitions ||\n      (useInitialIfEmpty ? initialLocation : undefined)\n  }\n\n  // Init initialLocation with potential location in store\n  initialLocation = getLocationInStore()\n\n  // If the store is replayed, update the URL in the browser to match.\n  if (adjustUrlOnReplay) {\n    const handleStoreChange = () => {\n      const locationInStore = getLocationInStore(true)\n      if (currentLocation === locationInStore || initialLocation === locationInStore) {\n        return\n      }\n\n      // Update address bar to reflect store state\n      isTimeTraveling = true\n      currentLocation = locationInStore\n      history.transitionTo({\n        ...locationInStore,\n        action: 'PUSH'\n      })\n      isTimeTraveling = false\n    }\n\n    unsubscribeFromStore = store.subscribe(handleStoreChange)\n    handleStoreChange()\n  }\n\n  // Whenever location changes, dispatch an action to get it in the store\n  const handleLocationChange = (location) => {\n    // ... unless we just caused that location change\n    if (isTimeTraveling) {\n      return\n    }\n\n    // Remember where we are\n    currentLocation = location\n\n    // Are we being called for the first time?\n    if (!initialLocation) {\n      // Remember as a fallback in case state is reset\n      initialLocation = location\n\n      // Respect persisted location, if any\n      if (getLocationInStore()) {\n        return\n      }\n    }\n\n    // Tell the store to update by dispatching an action\n    store.dispatch({\n      type: LOCATION_CHANGE,\n      payload: location\n    })\n  }\n  unsubscribeFromHistory = history.listen(handleLocationChange)\n\n  // History 3.x doesn't call listen synchronously, so fire the initial location change ourselves\n  if (history.getCurrentLocation) {\n    handleLocationChange(history.getCurrentLocation())\n  }\n\n  // The enhanced history uses store as source of truth\n  return {\n    ...history,\n    // The listeners are subscribed to the store instead of history\n    listen(listener) {\n      // Copy of last location.\n      let lastPublishedLocation = getLocationInStore(true)\n\n      // Keep track of whether we unsubscribed, as Redux store\n      // only applies changes in subscriptions on next dispatch\n      let unsubscribed = false\n      const unsubscribeFromStore = store.subscribe(() => {\n        const currentLocation = getLocationInStore(true)\n        if (currentLocation === lastPublishedLocation) {\n          return\n        }\n        lastPublishedLocation = currentLocation\n        if (!unsubscribed) {\n          listener(lastPublishedLocation)\n        }\n      })\n\n      // History 2.x listeners expect a synchronous call. Make the first call to the\n      // listener after subscribing to the store, in case the listener causes a\n      // location change (e.g. when it redirects)\n      if (!history.getCurrentLocation) {\n        listener(lastPublishedLocation)\n      }\n\n      // Let user unsubscribe later\n      return () => {\n        unsubscribed = true\n        unsubscribeFromStore()\n      }\n    },\n\n    // It also provides a way to destroy internal listeners\n    unsubscribe() {\n      if (adjustUrlOnReplay) {\n        unsubscribeFromStore()\n      }\n      unsubscribeFromHistory()\n    }\n  }\n}\n"]}