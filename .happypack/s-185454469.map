{"version":3,"sources":["node_modules/history/lib/AsyncUtils.js"],"names":["exports","__esModule","loopAsync","turns","work","callback","currentTurn","isDone","isSync","hasNext","doneArgs","done","_len","arguments","length","args","Array","_key","apply","undefined","next"],"mappings":"AAAA;;AAEAA,QAAQC,UAAR,GAAqB,IAArB;AACA,IAAIC,YAAYF,QAAQE,SAAR,GAAoB,SAASA,SAAT,CAAmBC,KAAnB,EAA0BC,IAA1B,EAAgCC,QAAhC,EAA0C;AAC5E,MAAIC,cAAc,CAAlB;AAAA,MACIC,SAAS,KADb;AAEA,MAAIC,SAAS,KAAb;AAAA,MACIC,UAAU,KADd;AAAA,MAEIC,WAAW,KAAK,CAFpB;;AAIA,MAAIC,OAAO,SAASA,IAAT,GAAgB;AACzB,SAAK,IAAIC,OAAOC,UAAUC,MAArB,EAA6BC,OAAOC,MAAMJ,IAAN,CAApC,EAAiDK,OAAO,CAA7D,EAAgEA,OAAOL,IAAvE,EAA6EK,MAA7E,EAAqF;AACnFF,WAAKE,IAAL,IAAaJ,UAAUI,IAAV,CAAb;AACD;;AAEDV,aAAS,IAAT;;AAEA,QAAIC,MAAJ,EAAY;AACV;AACAE,iBAAWK,IAAX;AACA;AACD;;AAEDV,aAASa,KAAT,CAAeC,SAAf,EAA0BJ,IAA1B;AACD,GAdD;;AAgBA,MAAIK,OAAO,SAASA,IAAT,GAAgB;AACzB,QAAIb,MAAJ,EAAY;;AAEZE,cAAU,IAAV;;AAEA,QAAID,MAAJ,EAAY,OALa,CAKL;;AAEpBA,aAAS,IAAT;;AAEA,WAAO,CAACD,MAAD,IAAWD,cAAcH,KAAzB,IAAkCM,OAAzC,EAAkD;AAChDA,gBAAU,KAAV;AACAL,WAAKE,aAAL,EAAoBc,IAApB,EAA0BT,IAA1B;AACD;;AAEDH,aAAS,KAAT;;AAEA,QAAID,MAAJ,EAAY;AACV;AACAF,eAASa,KAAT,CAAeC,SAAf,EAA0BT,QAA1B;AACA;AACD;;AAED,QAAIJ,eAAeH,KAAf,IAAwBM,OAA5B,EAAqC;AACnCF,eAAS,IAAT;AACAF;AACD;AACF,GA1BD;;AA4BAe;AACD,CApDD","file":"AsyncUtils.js","sourceRoot":"/Users/creator/workspace/furuida","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nvar loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {\n  var currentTurn = 0,\n      isDone = false;\n  var isSync = false,\n      hasNext = false,\n      doneArgs = void 0;\n\n  var done = function done() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    isDone = true;\n\n    if (isSync) {\n      // Iterate instead of recursing if possible.\n      doneArgs = args;\n      return;\n    }\n\n    callback.apply(undefined, args);\n  };\n\n  var next = function next() {\n    if (isDone) return;\n\n    hasNext = true;\n\n    if (isSync) return; // Iterate instead of recursing if possible.\n\n    isSync = true;\n\n    while (!isDone && currentTurn < turns && hasNext) {\n      hasNext = false;\n      work(currentTurn++, next, done);\n    }\n\n    isSync = false;\n\n    if (isDone) {\n      // This means the loop finished synchronously.\n      callback.apply(undefined, doneArgs);\n      return;\n    }\n\n    if (currentTurn >= turns && hasNext) {\n      isDone = true;\n      callback();\n    }\n  };\n\n  next();\n};"]}