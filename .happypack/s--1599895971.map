{"version":3,"sources":["public/src/js_components/react-router/modules/AsyncUtils.js"],"names":["loopAsync","mapAsync","turns","work","callback","currentTurn","isDone","sync","hasNext","doneArgs","done","arguments","apply","next","call","array","length","values","doneCount","index","error","value","forEach","item"],"mappings":";;;QAAgBA,S,GAAAA,S;QAkDAC,Q,GAAAA,Q;AAlDT,SAASD,SAAT,CAAmBE,KAAnB,EAA0BC,IAA1B,EAAgCC,QAAhC,EAA0C;AAC/C,MAAIC,cAAc,CAAlB;AAAA,MAAqBC,SAAS,KAA9B;AACA,MAAIC,OAAO,KAAX;AAAA,MAAkBC,UAAU,KAA5B;AAAA,MAAmCC,iBAAnC;;AAEA,WAASC,IAAT,GAAgB;AACdJ,aAAS,IAAT;AACA,QAAIC,IAAJ,EAAU;AACR;AACAE,sDAAgBE,SAAhB;AACA;AACD;;AAEDP,aAASQ,KAAT,CAAe,IAAf,EAAqBD,SAArB;AACD;;AAED,WAASE,IAAT,GAAgB;AACd,QAAIP,MAAJ,EAAY;AACV;AACD;;AAEDE,cAAU,IAAV;AACA,QAAID,IAAJ,EAAU;AACR;AACA;AACD;;AAEDA,WAAO,IAAP;;AAEA,WAAO,CAACD,MAAD,IAAWD,cAAcH,KAAzB,IAAkCM,OAAzC,EAAkD;AAChDA,gBAAU,KAAV;AACAL,WAAKW,IAAL,CAAU,IAAV,EAAgBT,aAAhB,EAA+BQ,IAA/B,EAAqCH,IAArC;AACD;;AAEDH,WAAO,KAAP;;AAEA,QAAID,MAAJ,EAAY;AACV;AACAF,eAASQ,KAAT,CAAe,IAAf,EAAqBH,QAArB;AACA;AACD;;AAED,QAAIJ,eAAeH,KAAf,IAAwBM,OAA5B,EAAqC;AACnCF,eAAS,IAAT;AACAF;AACD;AACF;;AAEDS;AACD;;AAEM,SAASZ,QAAT,CAAkBc,KAAlB,EAAyBZ,IAAzB,EAA+BC,QAA/B,EAAyC;AAC9C,MAAMY,SAASD,MAAMC,MAArB;AACA,MAAMC,SAAS,EAAf;;AAEA,MAAID,WAAW,CAAf,EACE,OAAOZ,SAAS,IAAT,EAAea,MAAf,CAAP;;AAEF,MAAIX,SAAS,KAAb;AAAA,MAAoBY,YAAY,CAAhC;;AAEA,WAASR,IAAT,CAAcS,KAAd,EAAqBC,KAArB,EAA4BC,KAA5B,EAAmC;AACjC,QAAIf,MAAJ,EACE;;AAEF,QAAIc,KAAJ,EAAW;AACTd,eAAS,IAAT;AACAF,eAASgB,KAAT;AACD,KAHD,MAGO;AACLH,aAAOE,KAAP,IAAgBE,KAAhB;;AAEAf,eAAU,EAAEY,SAAF,KAAgBF,MAA1B;;AAEA,UAAIV,MAAJ,EACEF,SAAS,IAAT,EAAea,MAAf;AACH;AACF;;AAEDF,QAAMO,OAAN,CAAc,UAAUC,IAAV,EAAgBJ,KAAhB,EAAuB;AACnChB,SAAKoB,IAAL,EAAWJ,KAAX,EAAkB,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AACxCX,WAAKS,KAAL,EAAYC,KAAZ,EAAmBC,KAAnB;AACD,KAFD;AAGD,GAJD;AAKD","file":"AsyncUtils.js","sourceRoot":"/Users/creator/workspace/furuida","sourcesContent":["export function loopAsync(turns, work, callback) {\n  let currentTurn = 0, isDone = false\n  let sync = false, hasNext = false, doneArgs\n\n  function done() {\n    isDone = true\n    if (sync) {\n      // Iterate instead of recursing if possible.\n      doneArgs = [ ...arguments ]\n      return\n    }\n\n    callback.apply(this, arguments)\n  }\n\n  function next() {\n    if (isDone) {\n      return\n    }\n\n    hasNext = true\n    if (sync) {\n      // Iterate instead of recursing if possible.\n      return\n    }\n\n    sync = true\n\n    while (!isDone && currentTurn < turns && hasNext) {\n      hasNext = false\n      work.call(this, currentTurn++, next, done)\n    }\n\n    sync = false\n\n    if (isDone) {\n      // This means the loop finished synchronously.\n      callback.apply(this, doneArgs)\n      return\n    }\n\n    if (currentTurn >= turns && hasNext) {\n      isDone = true\n      callback()\n    }\n  }\n\n  next()\n}\n\nexport function mapAsync(array, work, callback) {\n  const length = array.length\n  const values = []\n\n  if (length === 0)\n    return callback(null, values)\n\n  let isDone = false, doneCount = 0\n\n  function done(index, error, value) {\n    if (isDone)\n      return\n\n    if (error) {\n      isDone = true\n      callback(error)\n    } else {\n      values[index] = value\n\n      isDone = (++doneCount === length)\n\n      if (isDone)\n        callback(null, values)\n    }\n  }\n\n  array.forEach(function (item, index) {\n    work(item, index, function (error, value) {\n      done(index, error, value)\n    })\n  })\n}\n"]}