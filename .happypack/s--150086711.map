{"version":3,"sources":["public/src/js_components/react-router/modules/matchRoutes.js"],"names":["matchRoutes","getChildRoutes","route","location","paramNames","paramValues","callback","childRoutes","sync","result","partialNextState","params","createParams","childRoutesReturn","error","then","getIndexRoute","indexRoute","indexRoutesReturn","onChildRoutes","pathless","filter","childRoute","path","length","index","next","done","routes","concat","Array","isArray","err","assignParams","reduce","paramName","paramValue","push","matchRouteDeep","remainingPathname","pattern","charAt","pathname","matched","match","every","unshift","undefined"],"mappings":"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","file":"matchRoutes.js","sourceRoot":"/Users/creator/workspace/furuida","sourcesContent":["import { loopAsync } from './AsyncUtils'\nimport { isPromise } from './PromiseUtils'\nimport { matchPattern } from './PatternUtils'\nimport warning from './routerWarning'\nimport { createRoutes } from './RouteUtils'\n\nfunction getChildRoutes(route, location, paramNames, paramValues, callback) {\n  if (route.childRoutes) {\n    return [ null, route.childRoutes ]\n  }\n  if (!route.getChildRoutes) {\n    return []\n  }\n\n  let sync = true, result\n\n  const partialNextState = {\n    location,\n    params: createParams(paramNames, paramValues)\n  }\n\n  const childRoutesReturn = route.getChildRoutes(partialNextState, (error, childRoutes) => {\n    childRoutes = !error && createRoutes(childRoutes)\n    if (sync) {\n      result = [ error, childRoutes ]\n      return\n    }\n\n    callback(error, childRoutes)\n  })\n\n  if (isPromise(childRoutesReturn))\n    childRoutesReturn\n      .then(\n        childRoutes => callback(null, createRoutes(childRoutes)),\n        callback\n      )\n\n  sync = false\n  return result  // Might be undefined.\n}\n\nfunction getIndexRoute(route, location, paramNames, paramValues, callback) {\n  if (route.indexRoute) {\n    callback(null, route.indexRoute)\n  } else if (route.getIndexRoute) {\n    const partialNextState = {\n      location,\n      params: createParams(paramNames, paramValues)\n    }\n\n    const indexRoutesReturn = route.getIndexRoute(partialNextState, (error, indexRoute) => {\n      callback(error, !error && createRoutes(indexRoute)[0])\n    })\n\n    if (isPromise(indexRoutesReturn))\n      indexRoutesReturn\n        .then(\n          indexRoute => callback(null, createRoutes(indexRoute)[0]),\n          callback\n        )\n  } else if (route.childRoutes || route.getChildRoutes) {\n    const onChildRoutes = (error, childRoutes) => {\n      if (error) {\n        callback(error)\n        return\n      }\n\n      const pathless = childRoutes.filter(childRoute => !childRoute.path)\n\n      loopAsync(pathless.length, function (index, next, done) {\n        getIndexRoute(\n          pathless[index], location, paramNames, paramValues,\n          function (error, indexRoute) {\n            if (error || indexRoute) {\n              const routes = [ pathless[index] ].concat(\n                Array.isArray(indexRoute) ? indexRoute : [ indexRoute ]\n              )\n              done(error, routes)\n            } else {\n              next()\n            }\n          }\n        )\n      }, function (err, routes) {\n        callback(null, routes)\n      })\n    }\n\n    const result = getChildRoutes(\n      route, location, paramNames, paramValues, onChildRoutes\n    )\n    if (result) {\n      onChildRoutes(...result)\n    }\n  } else {\n    callback()\n  }\n}\n\nfunction assignParams(params, paramNames, paramValues) {\n  return paramNames.reduce(function (params, paramName, index) {\n    const paramValue = paramValues && paramValues[index]\n\n    if (Array.isArray(params[paramName])) {\n      params[paramName].push(paramValue)\n    } else if (paramName in params) {\n      params[paramName] = [ params[paramName], paramValue ]\n    } else {\n      params[paramName] = paramValue\n    }\n\n    return params\n  }, params)\n}\n\nfunction createParams(paramNames, paramValues) {\n  return assignParams({}, paramNames, paramValues)\n}\n\nfunction matchRouteDeep(\n  route, location, remainingPathname, paramNames, paramValues, callback\n) {\n  let pattern = route.path || ''\n\n  if (pattern.charAt(0) === '/') {\n    remainingPathname = location.pathname\n    paramNames = []\n    paramValues = []\n  }\n\n  // Only try to match the path if the route actually has a pattern, and if\n  // we're not just searching for potential nested absolute paths.\n  if (remainingPathname !== null && pattern) {\n    try {\n      const matched = matchPattern(pattern, remainingPathname)\n      if (matched) {\n        remainingPathname = matched.remainingPathname\n        paramNames = [ ...paramNames, ...matched.paramNames ]\n        paramValues = [ ...paramValues, ...matched.paramValues ]\n      } else {\n        remainingPathname = null\n      }\n    } catch (error) {\n      callback(error)\n    }\n\n    // By assumption, pattern is non-empty here, which is the prerequisite for\n    // actually terminating a match.\n    if (remainingPathname === '') {\n      const match = {\n        routes: [ route ],\n        params: createParams(paramNames, paramValues)\n      }\n\n      getIndexRoute(\n        route, location, paramNames, paramValues,\n        function (error, indexRoute) {\n          if (error) {\n            callback(error)\n          } else {\n            if (Array.isArray(indexRoute)) {\n              warning(\n                indexRoute.every(route => !route.path),\n                'Index routes should not have paths'\n              )\n              match.routes.push(...indexRoute)\n            } else if (indexRoute) {\n              warning(\n                !indexRoute.path,\n                'Index routes should not have paths'\n              )\n              match.routes.push(indexRoute)\n            }\n\n            callback(null, match)\n          }\n        }\n      )\n\n      return\n    }\n  }\n\n  if (remainingPathname != null || route.childRoutes) {\n    // Either a) this route matched at least some of the path or b)\n    // we don't have to load this route's children asynchronously. In\n    // either case continue checking for matches in the subtree.\n    const onChildRoutes = (error, childRoutes) => {\n      if (error) {\n        callback(error)\n      } else if (childRoutes) {\n        // Check the child routes to see if any of them match.\n        matchRoutes(childRoutes, location, function (error, match) {\n          if (error) {\n            callback(error)\n          } else if (match) {\n            // A child route matched! Augment the match and pass it up the stack.\n            match.routes.unshift(route)\n            callback(null, match)\n          } else {\n            callback()\n          }\n        }, remainingPathname, paramNames, paramValues)\n      } else {\n        callback()\n      }\n    }\n\n    const result = getChildRoutes(\n      route, location, paramNames, paramValues, onChildRoutes\n    )\n    if (result) {\n      onChildRoutes(...result)\n    }\n  } else {\n    callback()\n  }\n}\n\n/**\n * Asynchronously matches the given location to a set of routes and calls\n * callback(error, state) when finished. The state object will have the\n * following properties:\n *\n * - routes       An array of routes that matched, in hierarchical order\n * - params       An object of URL parameters\n *\n * Note: This operation may finish synchronously if no routes have an\n * asynchronous getChildRoutes method.\n */\nexport default function matchRoutes(\n  routes, location, callback,\n  remainingPathname, paramNames=[], paramValues=[]\n) {\n  if (remainingPathname === undefined) {\n    // TODO: This is a little bit ugly, but it works around a quirk in history\n    // that strips the leading slash from pathnames when using basenames with\n    // trailing slashes.\n    if (location.pathname.charAt(0) !== '/') {\n      location = {\n        ...location,\n        pathname: `/${location.pathname}`\n      }\n    }\n    remainingPathname = location.pathname\n  }\n\n  loopAsync(routes.length, function (index, next, done) {\n    matchRouteDeep(\n      routes[index], location, remainingPathname, paramNames, paramValues,\n      function (error, match) {\n        if (error || match) {\n          done(error, match)\n        } else {\n          next()\n        }\n      }\n    )\n  }, callback)\n}\n"]}